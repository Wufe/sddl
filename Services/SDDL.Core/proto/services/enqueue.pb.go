// Code generated by protoc-gen-go. DO NOT EDIT.
// source: enqueue.proto

package services

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DownloadStatus int32

const (
	DownloadStatus_IDLE         DownloadStatus = 0
	DownloadStatus_ACKNOWLEDGED DownloadStatus = 1
)

var DownloadStatus_name = map[int32]string{
	0: "IDLE",
	1: "ACKNOWLEDGED",
}

var DownloadStatus_value = map[string]int32{
	"IDLE":         0,
	"ACKNOWLEDGED": 1,
}

func (x DownloadStatus) String() string {
	return proto.EnumName(DownloadStatus_name, int32(x))
}

func (DownloadStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{0}
}

type HookEventType int32

const (
	HookEventType_UNDEFINED HookEventType = 0
	HookEventType_START     HookEventType = 1
	HookEventType_RETRY     HookEventType = 2
	HookEventType_STOP      HookEventType = 3
	HookEventType_ABORT     HookEventType = 4
	HookEventType_ADDED     HookEventType = 5
)

var HookEventType_name = map[int32]string{
	0: "UNDEFINED",
	1: "START",
	2: "RETRY",
	3: "STOP",
	4: "ABORT",
	5: "ADDED",
}

var HookEventType_value = map[string]int32{
	"UNDEFINED": 0,
	"START":     1,
	"RETRY":     2,
	"STOP":      3,
	"ABORT":     4,
	"ADDED":     5,
}

func (x HookEventType) String() string {
	return proto.EnumName(HookEventType_name, int32(x))
}

func (HookEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{1}
}

type LogType int32

const (
	LogType_TRACE       LogType = 0
	LogType_DEBUG       LogType = 1
	LogType_INFORMATION LogType = 2
	LogType_WARNING     LogType = 3
	LogType_ERROR       LogType = 4
	LogType_CRITICAL    LogType = 5
)

var LogType_name = map[int32]string{
	0: "TRACE",
	1: "DEBUG",
	2: "INFORMATION",
	3: "WARNING",
	4: "ERROR",
	5: "CRITICAL",
}

var LogType_value = map[string]int32{
	"TRACE":       0,
	"DEBUG":       1,
	"INFORMATION": 2,
	"WARNING":     3,
	"ERROR":       4,
	"CRITICAL":    5,
}

func (x LogType) String() string {
	return proto.EnumName(LogType_name, int32(x))
}

func (LogType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{2}
}

type DownloadInputValueObject struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Retries              int32    `protobuf:"varint,2,opt,name=retries,proto3" json:"retries,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadInputValueObject) Reset()         { *m = DownloadInputValueObject{} }
func (m *DownloadInputValueObject) String() string { return proto.CompactTextString(m) }
func (*DownloadInputValueObject) ProtoMessage()    {}
func (*DownloadInputValueObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{0}
}

func (m *DownloadInputValueObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadInputValueObject.Unmarshal(m, b)
}
func (m *DownloadInputValueObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadInputValueObject.Marshal(b, m, deterministic)
}
func (m *DownloadInputValueObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadInputValueObject.Merge(m, src)
}
func (m *DownloadInputValueObject) XXX_Size() int {
	return xxx_messageInfo_DownloadInputValueObject.Size(m)
}
func (m *DownloadInputValueObject) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadInputValueObject.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadInputValueObject proto.InternalMessageInfo

func (m *DownloadInputValueObject) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *DownloadInputValueObject) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

type DownloadOutputEntityModel struct {
	Id                   int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Uuid                 string         `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Url                  string         `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	Retries              int32          `protobuf:"varint,4,opt,name=retries,proto3" json:"retries,omitempty"`
	Status               DownloadStatus `protobuf:"varint,5,opt,name=status,proto3,enum=services.DownloadStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DownloadOutputEntityModel) Reset()         { *m = DownloadOutputEntityModel{} }
func (m *DownloadOutputEntityModel) String() string { return proto.CompactTextString(m) }
func (*DownloadOutputEntityModel) ProtoMessage()    {}
func (*DownloadOutputEntityModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{1}
}

func (m *DownloadOutputEntityModel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadOutputEntityModel.Unmarshal(m, b)
}
func (m *DownloadOutputEntityModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadOutputEntityModel.Marshal(b, m, deterministic)
}
func (m *DownloadOutputEntityModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadOutputEntityModel.Merge(m, src)
}
func (m *DownloadOutputEntityModel) XXX_Size() int {
	return xxx_messageInfo_DownloadOutputEntityModel.Size(m)
}
func (m *DownloadOutputEntityModel) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadOutputEntityModel.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadOutputEntityModel proto.InternalMessageInfo

func (m *DownloadOutputEntityModel) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DownloadOutputEntityModel) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *DownloadOutputEntityModel) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *DownloadOutputEntityModel) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *DownloadOutputEntityModel) GetStatus() DownloadStatus {
	if m != nil {
		return m.Status
	}
	return DownloadStatus_IDLE
}

type ListenHooksInputValueObject struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListenHooksInputValueObject) Reset()         { *m = ListenHooksInputValueObject{} }
func (m *ListenHooksInputValueObject) String() string { return proto.CompactTextString(m) }
func (*ListenHooksInputValueObject) ProtoMessage()    {}
func (*ListenHooksInputValueObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{2}
}

func (m *ListenHooksInputValueObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListenHooksInputValueObject.Unmarshal(m, b)
}
func (m *ListenHooksInputValueObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListenHooksInputValueObject.Marshal(b, m, deterministic)
}
func (m *ListenHooksInputValueObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenHooksInputValueObject.Merge(m, src)
}
func (m *ListenHooksInputValueObject) XXX_Size() int {
	return xxx_messageInfo_ListenHooksInputValueObject.Size(m)
}
func (m *ListenHooksInputValueObject) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenHooksInputValueObject.DiscardUnknown(m)
}

var xxx_messageInfo_ListenHooksInputValueObject proto.InternalMessageInfo

type DownloadHookEvent struct {
	Type                 HookEventType              `protobuf:"varint,1,opt,name=type,proto3,enum=services.HookEventType" json:"type,omitempty"`
	Download             *DownloadOutputEntityModel `protobuf:"bytes,2,opt,name=download,proto3" json:"download,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *DownloadHookEvent) Reset()         { *m = DownloadHookEvent{} }
func (m *DownloadHookEvent) String() string { return proto.CompactTextString(m) }
func (*DownloadHookEvent) ProtoMessage()    {}
func (*DownloadHookEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{3}
}

func (m *DownloadHookEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadHookEvent.Unmarshal(m, b)
}
func (m *DownloadHookEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadHookEvent.Marshal(b, m, deterministic)
}
func (m *DownloadHookEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadHookEvent.Merge(m, src)
}
func (m *DownloadHookEvent) XXX_Size() int {
	return xxx_messageInfo_DownloadHookEvent.Size(m)
}
func (m *DownloadHookEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadHookEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadHookEvent proto.InternalMessageInfo

func (m *DownloadHookEvent) GetType() HookEventType {
	if m != nil {
		return m.Type
	}
	return HookEventType_UNDEFINED
}

func (m *DownloadHookEvent) GetDownload() *DownloadOutputEntityModel {
	if m != nil {
		return m.Download
	}
	return nil
}

type LogInputValueObject struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Type                 LogType  `protobuf:"varint,2,opt,name=type,proto3,enum=services.LogType" json:"type,omitempty"`
	Sender               *Sender  `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogInputValueObject) Reset()         { *m = LogInputValueObject{} }
func (m *LogInputValueObject) String() string { return proto.CompactTextString(m) }
func (*LogInputValueObject) ProtoMessage()    {}
func (*LogInputValueObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{4}
}

func (m *LogInputValueObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogInputValueObject.Unmarshal(m, b)
}
func (m *LogInputValueObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogInputValueObject.Marshal(b, m, deterministic)
}
func (m *LogInputValueObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogInputValueObject.Merge(m, src)
}
func (m *LogInputValueObject) XXX_Size() int {
	return xxx_messageInfo_LogInputValueObject.Size(m)
}
func (m *LogInputValueObject) XXX_DiscardUnknown() {
	xxx_messageInfo_LogInputValueObject.DiscardUnknown(m)
}

var xxx_messageInfo_LogInputValueObject proto.InternalMessageInfo

func (m *LogInputValueObject) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *LogInputValueObject) GetType() LogType {
	if m != nil {
		return m.Type
	}
	return LogType_TRACE
}

func (m *LogInputValueObject) GetSender() *Sender {
	if m != nil {
		return m.Sender
	}
	return nil
}

type Sender struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Signature            string   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sender) Reset()         { *m = Sender{} }
func (m *Sender) String() string { return proto.CompactTextString(m) }
func (*Sender) ProtoMessage()    {}
func (*Sender) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{5}
}

func (m *Sender) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Sender.Unmarshal(m, b)
}
func (m *Sender) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Sender.Marshal(b, m, deterministic)
}
func (m *Sender) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sender.Merge(m, src)
}
func (m *Sender) XXX_Size() int {
	return xxx_messageInfo_Sender.Size(m)
}
func (m *Sender) XXX_DiscardUnknown() {
	xxx_messageInfo_Sender.DiscardUnknown(m)
}

var xxx_messageInfo_Sender proto.InternalMessageInfo

func (m *Sender) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Sender) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type LogOutputValueObject struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogOutputValueObject) Reset()         { *m = LogOutputValueObject{} }
func (m *LogOutputValueObject) String() string { return proto.CompactTextString(m) }
func (*LogOutputValueObject) ProtoMessage()    {}
func (*LogOutputValueObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{6}
}

func (m *LogOutputValueObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogOutputValueObject.Unmarshal(m, b)
}
func (m *LogOutputValueObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogOutputValueObject.Marshal(b, m, deterministic)
}
func (m *LogOutputValueObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogOutputValueObject.Merge(m, src)
}
func (m *LogOutputValueObject) XXX_Size() int {
	return xxx_messageInfo_LogOutputValueObject.Size(m)
}
func (m *LogOutputValueObject) XXX_DiscardUnknown() {
	xxx_messageInfo_LogOutputValueObject.DiscardUnknown(m)
}

var xxx_messageInfo_LogOutputValueObject proto.InternalMessageInfo

type ListenLogInputValueObject struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListenLogInputValueObject) Reset()         { *m = ListenLogInputValueObject{} }
func (m *ListenLogInputValueObject) String() string { return proto.CompactTextString(m) }
func (*ListenLogInputValueObject) ProtoMessage()    {}
func (*ListenLogInputValueObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_5dbf95ec3d1ab285, []int{7}
}

func (m *ListenLogInputValueObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListenLogInputValueObject.Unmarshal(m, b)
}
func (m *ListenLogInputValueObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListenLogInputValueObject.Marshal(b, m, deterministic)
}
func (m *ListenLogInputValueObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenLogInputValueObject.Merge(m, src)
}
func (m *ListenLogInputValueObject) XXX_Size() int {
	return xxx_messageInfo_ListenLogInputValueObject.Size(m)
}
func (m *ListenLogInputValueObject) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenLogInputValueObject.DiscardUnknown(m)
}

var xxx_messageInfo_ListenLogInputValueObject proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("services.DownloadStatus", DownloadStatus_name, DownloadStatus_value)
	proto.RegisterEnum("services.HookEventType", HookEventType_name, HookEventType_value)
	proto.RegisterEnum("services.LogType", LogType_name, LogType_value)
	proto.RegisterType((*DownloadInputValueObject)(nil), "services.DownloadInputValueObject")
	proto.RegisterType((*DownloadOutputEntityModel)(nil), "services.DownloadOutputEntityModel")
	proto.RegisterType((*ListenHooksInputValueObject)(nil), "services.ListenHooksInputValueObject")
	proto.RegisterType((*DownloadHookEvent)(nil), "services.DownloadHookEvent")
	proto.RegisterType((*LogInputValueObject)(nil), "services.LogInputValueObject")
	proto.RegisterType((*Sender)(nil), "services.Sender")
	proto.RegisterType((*LogOutputValueObject)(nil), "services.LogOutputValueObject")
	proto.RegisterType((*ListenLogInputValueObject)(nil), "services.ListenLogInputValueObject")
}

func init() { proto.RegisterFile("enqueue.proto", fileDescriptor_5dbf95ec3d1ab285) }

var fileDescriptor_5dbf95ec3d1ab285 = []byte{
	// 639 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xdd, 0x4e, 0xdb, 0x4c,
	0x10, 0x8d, 0x9d, 0xff, 0x09, 0x84, 0x65, 0xf8, 0xf4, 0x11, 0xa0, 0x54, 0xc8, 0x08, 0x29, 0xa2,
	0x55, 0x84, 0xd2, 0xbb, 0xde, 0x54, 0x26, 0x76, 0x52, 0xab, 0xc6, 0x46, 0x1b, 0x03, 0xaa, 0xd4,
	0x5e, 0x18, 0xbc, 0x8a, 0xdc, 0x26, 0x76, 0x6a, 0xaf, 0xa9, 0xb8, 0x6b, 0x1f, 0xa4, 0x2f, 0xd0,
	0xd7, 0xea, 0x8b, 0x54, 0xfe, 0xcb, 0x0f, 0xa6, 0x55, 0xef, 0x66, 0x67, 0x67, 0xcf, 0x9c, 0x39,
	0x73, 0x6c, 0xd8, 0x64, 0xde, 0x97, 0x88, 0x45, 0xac, 0x37, 0x0f, 0x7c, 0xee, 0x63, 0x23, 0x64,
	0xc1, 0xbd, 0x7b, 0xc7, 0x42, 0x69, 0x08, 0x1d, 0xc5, 0xff, 0xea, 0x4d, 0x7d, 0xdb, 0xd1, 0xbc,
	0x79, 0xc4, 0xaf, 0xed, 0x69, 0xc4, 0xcc, 0xdb, 0x4f, 0xec, 0x8e, 0x23, 0x81, 0x72, 0x14, 0x4c,
	0x3b, 0xc2, 0x91, 0xd0, 0x6d, 0xd2, 0x38, 0xc4, 0x0e, 0xd4, 0x03, 0xc6, 0x03, 0x97, 0x85, 0x1d,
	0xf1, 0x48, 0xe8, 0x56, 0x69, 0x7e, 0x94, 0x7e, 0x08, 0xb0, 0x97, 0x03, 0x99, 0x11, 0x9f, 0x47,
	0x5c, 0xf5, 0xb8, 0xcb, 0x1f, 0x2e, 0x7c, 0x87, 0x4d, 0xb1, 0x0d, 0xa2, 0xeb, 0x24, 0x40, 0x65,
	0x2a, 0xba, 0x0e, 0x22, 0x54, 0xa2, 0xc8, 0x75, 0x12, 0x90, 0x26, 0x4d, 0xe2, 0xbc, 0x5b, 0xf9,
	0xc9, 0x6e, 0x95, 0xb5, 0x6e, 0x78, 0x06, 0xb5, 0x90, 0xdb, 0x3c, 0x0a, 0x3b, 0xd5, 0x23, 0xa1,
	0xdb, 0xee, 0x77, 0x7a, 0xf9, 0x40, 0xbd, 0x9c, 0xc4, 0x38, 0xb9, 0xa7, 0x59, 0x9d, 0x74, 0x08,
	0x07, 0xba, 0x1b, 0x72, 0xe6, 0xbd, 0xf5, 0xfd, 0xcf, 0xe1, 0xe3, 0x51, 0xa5, 0xef, 0x02, 0x6c,
	0xe7, 0x2f, 0xe3, 0x0a, 0xf5, 0x9e, 0x79, 0x1c, 0x5f, 0x40, 0x85, 0x3f, 0xcc, 0x59, 0x42, 0xbc,
	0xdd, 0xdf, 0x5d, 0x36, 0x59, 0x94, 0x58, 0x0f, 0x73, 0x46, 0x93, 0x22, 0x7c, 0x03, 0x0d, 0x27,
	0x43, 0x48, 0xe6, 0x6a, 0xf5, 0x8f, 0x8b, 0xac, 0x0a, 0xd2, 0xd0, 0xc5, 0x23, 0xe9, 0x9b, 0x00,
	0x3b, 0xba, 0x3f, 0x29, 0xac, 0xa1, 0x03, 0xf5, 0x19, 0x0b, 0x43, 0x7b, 0xc2, 0xb2, 0x55, 0xe4,
	0x47, 0x3c, 0xc9, 0xf8, 0x89, 0x09, 0xbf, 0xed, 0x65, 0x3b, 0xdd, 0x9f, 0xac, 0x30, 0xeb, 0x42,
	0x2d, 0x64, 0x9e, 0xc3, 0x82, 0x44, 0xdc, 0x56, 0x9f, 0x2c, 0x0b, 0xc7, 0x49, 0x9e, 0x66, 0xf7,
	0xd2, 0x6b, 0xa8, 0xa5, 0x99, 0x78, 0x43, 0x9e, 0x3d, 0xcb, 0x3b, 0x26, 0x31, 0x3e, 0x83, 0x66,
	0xe8, 0x4e, 0x3c, 0x9b, 0x47, 0x01, 0xcb, 0x56, 0xb7, 0x4c, 0x48, 0xff, 0xc3, 0x7f, 0xba, 0x3f,
	0x49, 0x07, 0x5c, 0x95, 0xf6, 0x00, 0xf6, 0x52, 0xe5, 0x9f, 0x98, 0xed, 0xf4, 0x25, 0xb4, 0xd7,
	0x17, 0x86, 0x0d, 0xa8, 0x68, 0x8a, 0xae, 0x92, 0x12, 0x12, 0xd8, 0x90, 0x07, 0xef, 0x0c, 0xf3,
	0x46, 0x57, 0x95, 0x91, 0xaa, 0x10, 0xe1, 0xd4, 0x82, 0xcd, 0x35, 0xe5, 0x71, 0x13, 0x9a, 0x57,
	0x86, 0xa2, 0x0e, 0x35, 0x43, 0x55, 0x48, 0x09, 0x9b, 0x50, 0x1d, 0x5b, 0x32, 0xb5, 0x88, 0x10,
	0x87, 0x54, 0xb5, 0xe8, 0x7b, 0x22, 0xc6, 0x88, 0x63, 0xcb, 0xbc, 0x24, 0xe5, 0x38, 0x29, 0x9f,
	0x9b, 0xd4, 0x22, 0x95, 0x24, 0x54, 0x14, 0x55, 0x21, 0xd5, 0xd3, 0x6b, 0xa8, 0x67, 0x7a, 0xc5,
	0x59, 0x8b, 0xca, 0x03, 0x35, 0xc5, 0x52, 0xd4, 0xf3, 0xab, 0x11, 0x11, 0x70, 0x0b, 0x5a, 0x9a,
	0x31, 0x34, 0xe9, 0x85, 0x6c, 0x69, 0xa6, 0x41, 0x44, 0x6c, 0x41, 0xfd, 0x46, 0xa6, 0x86, 0x66,
	0x8c, 0x52, 0x50, 0x95, 0x52, 0x93, 0x92, 0x0a, 0x6e, 0x40, 0x63, 0x40, 0x35, 0x4b, 0x1b, 0xc8,
	0x3a, 0xa9, 0xf6, 0x7f, 0x89, 0x50, 0x57, 0xd3, 0xcf, 0x0e, 0x3f, 0xc0, 0x56, 0x16, 0xe6, 0xe3,
	0xa2, 0x54, 0x74, 0xc7, 0x63, 0x79, 0xf6, 0xff, 0xc5, 0x41, 0x52, 0x09, 0x3f, 0xc2, 0x4e, 0x2a,
	0xf1, 0xaa, 0x85, 0x43, 0x3c, 0x59, 0x31, 0xc4, 0x9f, 0xbd, 0xbf, 0x7f, 0x50, 0x6c, 0xb2, 0x50,
	0x59, 0x2a, 0x9d, 0x09, 0x38, 0x84, 0xb2, 0xee, 0x4f, 0xf0, 0x70, 0xcd, 0x5f, 0x05, 0x98, 0xe7,
	0x6b, 0xd7, 0x45, 0x1f, 0x94, 0x70, 0x0c, 0xcd, 0x85, 0x13, 0xf0, 0xf8, 0x31, 0xb9, 0xa7, 0x30,
	0xff, 0xde, 0x32, 0x26, 0x77, 0xbe, 0xff, 0x53, 0xdc, 0x1d, 0x2b, 0x8a, 0xde, 0x1b, 0xf8, 0xb3,
	0x59, 0xe4, 0xb9, 0x77, 0x36, 0x77, 0x7d, 0xaf, 0x37, 0xa2, 0x97, 0x83, 0xdb, 0x5a, 0xf2, 0xb7,
	0x7b, 0xf5, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x71, 0xfd, 0x37, 0xfe, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EnqueueClient is the client API for Enqueue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EnqueueClient interface {
	EnqueueDownload(ctx context.Context, in *DownloadInputValueObject, opts ...grpc.CallOption) (*DownloadOutputEntityModel, error)
	ListenDownloadHooks(ctx context.Context, in *ListenHooksInputValueObject, opts ...grpc.CallOption) (Enqueue_ListenDownloadHooksClient, error)
	Log(ctx context.Context, in *LogInputValueObject, opts ...grpc.CallOption) (*LogOutputValueObject, error)
	ListenLog(ctx context.Context, in *ListenLogInputValueObject, opts ...grpc.CallOption) (Enqueue_ListenLogClient, error)
}

type enqueueClient struct {
	cc grpc.ClientConnInterface
}

func NewEnqueueClient(cc grpc.ClientConnInterface) EnqueueClient {
	return &enqueueClient{cc}
}

func (c *enqueueClient) EnqueueDownload(ctx context.Context, in *DownloadInputValueObject, opts ...grpc.CallOption) (*DownloadOutputEntityModel, error) {
	out := new(DownloadOutputEntityModel)
	err := c.cc.Invoke(ctx, "/services.Enqueue/EnqueueDownload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enqueueClient) ListenDownloadHooks(ctx context.Context, in *ListenHooksInputValueObject, opts ...grpc.CallOption) (Enqueue_ListenDownloadHooksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Enqueue_serviceDesc.Streams[0], "/services.Enqueue/ListenDownloadHooks", opts...)
	if err != nil {
		return nil, err
	}
	x := &enqueueListenDownloadHooksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Enqueue_ListenDownloadHooksClient interface {
	Recv() (*DownloadHookEvent, error)
	grpc.ClientStream
}

type enqueueListenDownloadHooksClient struct {
	grpc.ClientStream
}

func (x *enqueueListenDownloadHooksClient) Recv() (*DownloadHookEvent, error) {
	m := new(DownloadHookEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *enqueueClient) Log(ctx context.Context, in *LogInputValueObject, opts ...grpc.CallOption) (*LogOutputValueObject, error) {
	out := new(LogOutputValueObject)
	err := c.cc.Invoke(ctx, "/services.Enqueue/Log", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enqueueClient) ListenLog(ctx context.Context, in *ListenLogInputValueObject, opts ...grpc.CallOption) (Enqueue_ListenLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Enqueue_serviceDesc.Streams[1], "/services.Enqueue/ListenLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &enqueueListenLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Enqueue_ListenLogClient interface {
	Recv() (*LogInputValueObject, error)
	grpc.ClientStream
}

type enqueueListenLogClient struct {
	grpc.ClientStream
}

func (x *enqueueListenLogClient) Recv() (*LogInputValueObject, error) {
	m := new(LogInputValueObject)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EnqueueServer is the server API for Enqueue service.
type EnqueueServer interface {
	EnqueueDownload(context.Context, *DownloadInputValueObject) (*DownloadOutputEntityModel, error)
	ListenDownloadHooks(*ListenHooksInputValueObject, Enqueue_ListenDownloadHooksServer) error
	Log(context.Context, *LogInputValueObject) (*LogOutputValueObject, error)
	ListenLog(*ListenLogInputValueObject, Enqueue_ListenLogServer) error
}

// UnimplementedEnqueueServer can be embedded to have forward compatible implementations.
type UnimplementedEnqueueServer struct {
}

func (*UnimplementedEnqueueServer) EnqueueDownload(ctx context.Context, req *DownloadInputValueObject) (*DownloadOutputEntityModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueDownload not implemented")
}
func (*UnimplementedEnqueueServer) ListenDownloadHooks(req *ListenHooksInputValueObject, srv Enqueue_ListenDownloadHooksServer) error {
	return status.Errorf(codes.Unimplemented, "method ListenDownloadHooks not implemented")
}
func (*UnimplementedEnqueueServer) Log(ctx context.Context, req *LogInputValueObject) (*LogOutputValueObject, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Log not implemented")
}
func (*UnimplementedEnqueueServer) ListenLog(req *ListenLogInputValueObject, srv Enqueue_ListenLogServer) error {
	return status.Errorf(codes.Unimplemented, "method ListenLog not implemented")
}

func RegisterEnqueueServer(s *grpc.Server, srv EnqueueServer) {
	s.RegisterService(&_Enqueue_serviceDesc, srv)
}

func _Enqueue_EnqueueDownload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadInputValueObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnqueueServer).EnqueueDownload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.Enqueue/EnqueueDownload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnqueueServer).EnqueueDownload(ctx, req.(*DownloadInputValueObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enqueue_ListenDownloadHooks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenHooksInputValueObject)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnqueueServer).ListenDownloadHooks(m, &enqueueListenDownloadHooksServer{stream})
}

type Enqueue_ListenDownloadHooksServer interface {
	Send(*DownloadHookEvent) error
	grpc.ServerStream
}

type enqueueListenDownloadHooksServer struct {
	grpc.ServerStream
}

func (x *enqueueListenDownloadHooksServer) Send(m *DownloadHookEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Enqueue_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogInputValueObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnqueueServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.Enqueue/Log",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnqueueServer).Log(ctx, req.(*LogInputValueObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enqueue_ListenLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenLogInputValueObject)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnqueueServer).ListenLog(m, &enqueueListenLogServer{stream})
}

type Enqueue_ListenLogServer interface {
	Send(*LogInputValueObject) error
	grpc.ServerStream
}

type enqueueListenLogServer struct {
	grpc.ServerStream
}

func (x *enqueueListenLogServer) Send(m *LogInputValueObject) error {
	return x.ServerStream.SendMsg(m)
}

var _Enqueue_serviceDesc = grpc.ServiceDesc{
	ServiceName: "services.Enqueue",
	HandlerType: (*EnqueueServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnqueueDownload",
			Handler:    _Enqueue_EnqueueDownload_Handler,
		},
		{
			MethodName: "Log",
			Handler:    _Enqueue_Log_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenDownloadHooks",
			Handler:       _Enqueue_ListenDownloadHooks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenLog",
			Handler:       _Enqueue_ListenLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "enqueue.proto",
}
